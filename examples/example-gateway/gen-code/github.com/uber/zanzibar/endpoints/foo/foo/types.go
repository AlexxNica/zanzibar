// Code generated by thriftrw v1.1.0
// @generated

package foo

import (
	"errors"
	"fmt"
	"go.uber.org/thriftrw/wire"
	"strings"
)

type FooName struct {
	Name *string `json:"name,omitempty"`
}

func (v *FooName) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *FooName) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *FooName) String() string {
	var fields [1]string
	i := 0
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}
	return fmt.Sprintf("FooName{%v}", strings.Join(fields[:i], ", "))
}

type FooStruct struct {
	FooString string              `json:"fooString"`
	FooI32    *int32              `json:"fooI32,omitempty"`
	FooI16    *int16              `json:"fooI16,omitempty"`
	FooDouble *float64            `json:"fooDouble,omitempty"`
	FooBool   *bool               `json:"fooBool,omitempty"`
	FooMap    map[string]*FooName `json:"fooMap"`
}

type _Map_String_FooName_MapItemList map[string]*FooName

func (m _Map_String_FooName_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := wire.NewValueString(k), error(nil)
		if err != nil {
			return err
		}
		vw, err := v.ToWire()
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_String_FooName_MapItemList) Size() int {
	return len(m)
}

func (_Map_String_FooName_MapItemList) KeyType() wire.Type {
	return wire.TBinary
}

func (_Map_String_FooName_MapItemList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Map_String_FooName_MapItemList) Close() {
}

func (v *FooStruct) ToWire() (wire.Value, error) {
	var (
		fields [6]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	w, err = wire.NewValueString(v.FooString), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.FooI32 != nil {
		w, err = wire.NewValueI32(*(v.FooI32)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.FooI16 != nil {
		w, err = wire.NewValueI16(*(v.FooI16)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.FooDouble != nil {
		w, err = wire.NewValueDouble(*(v.FooDouble)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.FooBool != nil {
		w, err = wire.NewValueBool(*(v.FooBool)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}
	if v.FooMap != nil {
		w, err = wire.NewValueMap(_Map_String_FooName_MapItemList(v.FooMap)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 6, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _FooName_Read(w wire.Value) (*FooName, error) {
	var v FooName
	err := v.FromWire(w)
	return &v, err
}

func _Map_String_FooName_Read(m wire.MapItemList) (map[string]*FooName, error) {
	if m.KeyType() != wire.TBinary {
		return nil, nil
	}
	if m.ValueType() != wire.TStruct {
		return nil, nil
	}
	o := make(map[string]*FooName, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetString(), error(nil)
		if err != nil {
			return err
		}
		v, err := _FooName_Read(x.Value)
		if err != nil {
			return err
		}
		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func (v *FooStruct) FromWire(w wire.Value) error {
	var err error
	fooStringIsSet := false
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.FooString, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				fooStringIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.FooI32 = &x
				if err != nil {
					return err
				}
			}
		case 3:
			if field.Value.Type() == wire.TI16 {
				var x int16
				x, err = field.Value.GetI16(), error(nil)
				v.FooI16 = &x
				if err != nil {
					return err
				}
			}
		case 4:
			if field.Value.Type() == wire.TDouble {
				var x float64
				x, err = field.Value.GetDouble(), error(nil)
				v.FooDouble = &x
				if err != nil {
					return err
				}
			}
		case 5:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.FooBool = &x
				if err != nil {
					return err
				}
			}
		case 6:
			if field.Value.Type() == wire.TMap {
				v.FooMap, err = _Map_String_FooName_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
			}
		}
	}
	if !fooStringIsSet {
		return errors.New("field FooString of FooStruct is required")
	}
	return nil
}

func (v *FooStruct) String() string {
	var fields [6]string
	i := 0
	fields[i] = fmt.Sprintf("FooString: %v", v.FooString)
	i++
	if v.FooI32 != nil {
		fields[i] = fmt.Sprintf("FooI32: %v", *(v.FooI32))
		i++
	}
	if v.FooI16 != nil {
		fields[i] = fmt.Sprintf("FooI16: %v", *(v.FooI16))
		i++
	}
	if v.FooDouble != nil {
		fields[i] = fmt.Sprintf("FooDouble: %v", *(v.FooDouble))
		i++
	}
	if v.FooBool != nil {
		fields[i] = fmt.Sprintf("FooBool: %v", *(v.FooBool))
		i++
	}
	if v.FooMap != nil {
		fields[i] = fmt.Sprintf("FooMap: %v", v.FooMap)
		i++
	}
	return fmt.Sprintf("FooStruct{%v}", strings.Join(fields[:i], ", "))
}
