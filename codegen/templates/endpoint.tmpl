{{/* template to render gateway http endpoint code */ -}}
// Code generated by zanzibar
// @generated

package {{.PackageName}}

import (
	"context"
	"io/ioutil"
	"net/http"

	"github.com/pkg/errors"
	"go.uber.org/zap"
	"{{.GatewayPackageName}}/clients"
	zanzibar "github.com/uber/zanzibar/runtime"

	{{range $idx, $pkg := .IncludedPackages -}}
	{{$pkg.AliasName}} "{{$pkg.PackageName}}"
	{{end -}}

	{{if .Method.Downstream }}
	{{- range $idx, $pkg := .Method.Downstream.IncludedPackages -}}
	{{$file := basePath $pkg.PackageName -}}
	{{$pkg.AliasName}} "{{$pkg.PackageName}}"
	{{end}}
	{{- end}}
)

{{ $workflow := .WorkflowName -}}
{{ $reqHeaderMap := .ReqHeaderMap -}}
{{ $resHeaderMap := .ResHeaderMap -}}
{{ $clientName := title .ClientName -}}
{{ $handlerName := title .Method.Name | printf "%sHandler" }}
{{with .Method -}}

// {{$handlerName}} is the handler for "{{.HTTPPath}}"
type {{$handlerName}} struct {
	Clients *clients.Clients
}

// New{{title .Name}}Endpoint creates a handler
func New{{title .Name}}Endpoint(
	gateway *zanzibar.Gateway,
) *{{$handlerName}} {
	return &{{$handlerName}}{
		Clients: gateway.Clients.(*clients.Clients),
	}
}

// HandleRequest handles "{{.HTTPPath}}".
func (handler *{{$handlerName}}) HandleRequest(
	ctx context.Context,
	req *zanzibar.ServerHTTPRequest,
	res *zanzibar.ServerHTTPResponse,
) {
	{{- if .ReqHeaders -}}
	if !req.CheckHeaders({{.ReqHeaders | printf "%#v" }}) {
		return
	}
	{{- end -}}

	{{if ne .RequestType ""}}
	var requestBody {{.RequestType}}
	if ok := req.ReadAndUnmarshalBody(&requestBody); !ok {
		return
	}
	{{end}}

	workflow := {{$workflow}}{
		Clients: handler.Clients,
		Logger: req.Logger,
		Request: req,
	}

	{{if and (eq .RequestType "") (eq .ResponseType "")}}
	respHeaders, err := workflow.Handle(ctx, req.Header)
	{{else if eq .RequestType ""}}
	response, respHeaders, err := workflow.Handle(ctx, req.Header)
	{{else if eq .ResponseType ""}}
	respHeaders, err := workflow.Handle(ctx, req.Header, &requestBody)
	{{else}}
	response, respHeaders, err := workflow.Handle(ctx, req.Header, &requestBody)
	{{end -}}
	if err != nil {
		req.Logger.Warn("Workflow for endpoint returned error",
			zap.String("error", err.Error()),
		)
		res.SendErrorString(500, "Unexpected server error")
		return
	}

	{{- if .ResHeaders }}
	// TODO(sindelar): implement check headers on response
	{{- end }}

	{{if eq .ResponseType "" -}}
	res.WriteJSONBytes({{.OKStatusCode.Code}}, respHeaders, nil)
	{{- else -}}
	res.WriteJSON({{.OKStatusCode.Code}}, respHeaders, response)
	{{- end -}}
}

{{end -}}

{{- if .Method.Downstream }}
{{- with .Method -}}
{{- $clientPackage := .Downstream.PackageName -}}
{{- $clientMethod := .DownstreamMethod -}}
{{- $clientReqType := fullTypeName ($clientMethod).RequestType ($clientPackage) -}}
{{- $clientResType := fullTypeName  ($clientMethod).ResponseType ($clientPackage) -}}
{{- $clientMethodName := title ($clientMethod).Name -}}


// {{$workflow}} calls thrift client {{$clientName}}.{{$clientMethodName}}
type {{$workflow}} struct {
	Clients *clients.Clients
	Logger  *zap.Logger
	Request *zanzibar.ServerHTTPRequest
}

// Handle calls thrift client.
func (w {{$workflow}}) Handle(
{{- if and (eq .RequestType "") (eq .ResponseType "") }}
	ctx context.Context,
	// TODO(sindelar): Switch to zanzibar.Headers when tchannel 
 	// generation is implemented.
	headers http.Header,
) (map[string]string, error) {
{{else if eq .RequestType "" }}
	ctx context.Context,
	// TODO(sindelar): Switch to zanzibar.Headers when tchannel 
 	// generation is implemented.	
	headers http.Header,
) (*{{.ResponseType}}, map[string]string, error) {
{{else if eq .ResponseType "" }}
	ctx context.Context,
	// TODO(sindelar): Switch to zanzibar.Headers when tchannel 
 	// generation is implemented.
	headers http.Header,
	r *{{.RequestType}},
) (map[string]string, error) {
{{else}}
	ctx context.Context,
	// TODO(sindelar): Switch to zanzibar.Headers when tchannel 
 	// generation is implemented.
	headers http.Header,
	r *{{.RequestType}},
) (*{{.ResponseType}}, map[string]string, error) {
{{- end}}
	{{- if ne .RequestType "" -}}
	clientRequest := convertTo{{title .Name}}ClientRequest(r)
	{{end}}
	clientHeaders := map[string]string{}
	for k, v := range {{ $reqHeaderMap | printf "%#v" }} {
		clientHeaders[v] = headers.Get(k)
	}

	{{if and (eq $clientReqType "") (eq $clientResType "")}}
		{{if (eq (len $resHeaderMap) 0) -}}
		_, err := w.Clients.{{$clientName}}.{{$clientMethodName}}(ctx, clientHeaders)
		{{else}}
		respHeaders, err := w.Clients.{{$clientName}}.{{$clientMethodName}}(ctx, clientHeaders)
		{{- end }}
	{{else if eq $clientReqType ""}}
		{{if (eq (len $resHeaderMap) 0) -}}
		clientRespBody, _, err := w.Clients.{{$clientName}}.{{$clientMethodName}}(
			ctx, clientHeaders,
		)
		{{else}}
		clientRespBody, respHeaders, err := w.Clients.{{$clientName}}.{{$clientMethodName}}(
			ctx, clientHeaders,
		)
		{{- end }}
	{{else if eq $clientResType ""}}
		{{if (eq (len $resHeaderMap) 0) -}}
		_, err := w.Clients.{{$clientName}}.{{$clientMethodName}}(
			ctx, clientHeaders, clientRequest,
		)
		{{else}}
		respHeaders, err := w.Clients.{{$clientName}}.{{$clientMethodName}}(
			ctx, clientHeaders, clientRequest,
		)
		{{- end }}
	{{else}}
		{{if (eq (len $resHeaderMap) 0) -}}
		clientRespBody, _, err := w.Clients.{{$clientName}}.{{$clientMethodName}}(
			ctx, clientHeaders, clientRequest,
		)
		{{else}}
		clientRespBody, respHeaders, err := w.Clients.{{$clientName}}.{{$clientMethodName}}(
			ctx, clientHeaders, clientRequest,
		)
		{{- end }}
	{{end -}}
	if err != nil {
		w.Logger.Warn("Could not make client request",
			zap.String("error", err.Error()),
		)
		// TODO(sindelar): Consider returning partial headers in error case.
		return {{if eq .ResponseType ""}}nil, err{{else}}nil, nil, err{{end}}
	}

	// Filter and map response headers from client to server response.
	endRespHead := map[string]string{}
	{{if (ne (len $resHeaderMap) 0) -}}
	for k, v := range {{$resHeaderMap | printf "%#v" }} {
		endRespHead[v] = respHeaders[k]
	}
	{{- end }}

	{{if eq .ResponseType "" -}}
	return endRespHead, nil
	{{- else -}}
	response := convert{{title .Name}}ClientResponse(clientRespBody)
	return response, endRespHead, nil
	{{- end -}}
}

{{if and (ne .RequestType "") (ne $clientReqType "") -}}
func convertTo{{title .Name}}ClientRequest(body *{{title .RequestType}}) *{{$clientReqType}} {
	clientRequest := &{{$clientReqType}}{}

	{{ range $key, $value := .RequestFieldMap -}}
	{{ range $name, $type := $.Method.RequestTypeMap -}} {{if eq $name $key -}}
	clientRequest.{{title $key }} = {{ $type }}(body.{{title $value }})
	{{ end -}}
	{{ end -}}
	{{ end }}
	return clientRequest
}
{{end -}}


{{if and (ne .ResponseType "") (ne $clientResType "") -}}
func convert{{title .Name}}ClientResponse(body *{{$clientResType}}) *{{.ResponseType}} {
	// TODO: Add response fields mapping here.
	downstreamResponse := (*{{.ResponseType}})(body)
	return downstreamResponse
}
{{end -}}

{{end -}}
{{end -}}
