{{- /* template to render edge gateway tchannel server code */ -}}
// Code generated by zanzibar
// @generated

// Package {{.PackageName}} is generated code used to handle TChannel calls using Thrift.
package {{.PackageName}}

import (
	"context"
	"errors"

	"go.uber.org/thriftrw/wire"
	"go.uber.org/zap"
	"{{.GatewayPackageName}}/clients"
	zanzibar "github.com/uber/zanzibar/runtime"

	{{range $idx, $pkg := .IncludedPackages -}}
	{{$pkg.AliasName}} "{{$pkg.PackageName}}"
	{{end -}}
)

{{$workflow := .WorkflowName -}}
{{$serviceMethod := printf "%s%s" .Method.ThriftService .Method.Name -}}
{{$handlerName := printf "%sHandler"  $serviceMethod -}}
{{$genCodePkg := .Method.GenCodePkgName -}}
{{with .Method -}}
// New{{$handlerName}} creates a handler to be registered with a thrift server.
func New{{$handlerName}}(
	gateway *zanzibar.Gateway,
) zanzibar.TChanHandler {
	return &{{$handlerName}}{
		Clients: gateway.Clients.(*clients.Clients),
		Logger: gateway.Logger,
	}
}

// {{$handlerName}} is the handler for "{{.ThriftService}}::{{.Name}}".
type {{$handlerName}} struct {
	Clients *clients.Clients
	Logger *zap.Logger
}

// Handle handles RPC call of "{{.ThriftService}}::{{.Name}}".
func (h *{{$handlerName}}) Handle(
	ctx context.Context,
	reqHeaders map[string]string,
	wireValue *wire.Value,
) (bool, zanzibar.RWTStruct, map[string]string, error) {
	wfReqHeaders := zanzibar.ServerTChannelHeader(reqHeaders)
	{{if .ReqHeaders -}}
	if err := wfReqHeaders.Ensure({{.ReqHeaders | printf "%#v" }}); err != nil {
		return false, nil, nil, err
	}
	{{- end}}

	var res {{$genCodePkg}}.{{.ThriftService}}_{{.Name}}_Result

	{{if ne .RequestType "" -}}
	var req {{.RequestType}}
	if err := req.FromWire(*wireValue); err != nil {
		return false, nil, nil, err
	}
	{{end -}}

	workflow := {{$workflow}}{
		Clients: h.Clients,
		Logger: h.Logger,
	}

	{{if and (eq .RequestType "") (eq .ResponseType "")}}
	wfRespHeaders, err := workflow.Handle(ctx, wfReqHeaders)
	{{else if eq .RequestType ""}}
	r, wfRespHeaders, err := workflow.Handle(ctx, wfReqHeaders)
	{{else if eq .ResponseType ""}}
	wfRespHeaders, err := workflow.Handle(ctx, wfReqHeaders, &req)
	{{else}}
	r, wfRespHeaders, err := workflow.Handle(ctx, wfReqHeaders, &req)
	{{end}}

	{{- if .ResHeaders}}
	if err := wfRespHeaders.Ensure({{.ResHeaders | printf "%#v" }}); err != nil {
		return false, nil, nil, err
	}
	{{- end}}

	respHeaders := map[string]string{}
	for _, key := range wfRespHeaders.Keys() {
		respHeaders[key], _ = wfReqHeaders.Get(key)
	}

	{{if eq (len .Exceptions) 0 -}}
		if err != nil {
			return false, nil, respHeaders, err
		}
		res.Success = r
	{{else -}}
		if err != nil {
			switch v := err.(type) {
			{{$method := .Name -}}
			{{range .Exceptions -}}
				case *{{.Type}}:
					if v == nil {
						return false, nil, respHeaders, errors.New(
							"Handler for {{$method}} returned non-nil error type *{{.Type}} but nil value",
						)
					}
					res.{{title .Name}} = v
			{{end -}}
				default:
					return false, nil, respHeaders, err
			}
		} {{if ne .ResponseType "" -}} else {
			res.Success = r
		} {{end -}}
	{{end}}

	return err == nil, &res, respHeaders, nil
}

{{end -}}
